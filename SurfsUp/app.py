# Imported all the dependencies:
import sqlalchemy
from sqlalchemy.ext.automap import automap_base
from sqlalchemy.orm import Session
from sqlalchemy import create_engine, func
from flask import Flask, jsonify
import numpy as np
import pandas as pd
import datetime as dt

#################################################
# Database Setup
#################################################
# Created an engine to my 'hawaii.sqlite' database:
engine = create_engine('sqlite:///Resources/hawaii.sqlite')

# Reflected the existing database into a new model:
Base = automap_base()

# Also reflected the tables:
Base.prepare(autoload_with=engine)

# Saved a reference to each table in the database:
station = Base.classes.station
measurement = Base.classes.measurement

# Created my session (link) from Python to the database:
session = Session(engine)

# Defined a function to find the date one year from the last date in the dataset; this function is used twice (in the precipitation and temperature routes):
def the_year_before():
    most_recent_datapoint = session.query(func.max(measurement.date)).scalar()
    reformatted_most_recent_datapoint = dt.datetime.strptime(most_recent_datapoint, '%Y-%m-%d').date()
    one_year_before = reformatted_most_recent_datapoint - dt.timedelta(days=365)
    return (one_year_before)

#################################################
# Flask Setup
#################################################

# Created an app to pass __name__:
app = Flask(__name__)

#################################################
# Flask Routes
#################################################

# Homepage route:
@app.route('/')
def homepage():
    print("The server received a request for the homepage...")
    return (
        f"<h1>Welcome to the API for <i>my Hawaiian Holiday</i>!</h1><br/>"
        f"This API will help you find all the weather info of the islands that I found while planning my Hawaiian holiday."
        f"<h2>Fascinating weather info:</h2>"
        f"/api/v1.0/precipitation <-- <i>This route leads to the data generated by the precipitation analysis I did of the last 12 months of data.</i><br/>"
        f"/api/v1.0/stations <-- <i>This route has data about the stations in Hawaii.</i><br/>"
        f"/api/v1.0/tobs <- <i>This route takes you to the dates and temperature observations of the most active station for the last year of data.</i><br/>"
        f"<h2>Find the stats of a specific period!</h2>"
        f"If you would like to know the minimum, average, and maximum temperature of specific dates in Hawaii, you can specify the start and end dates that you would like to query in the URL. Please use the YYYY-MM-DD format.</br>"
        f"</br>"
        f"/api/v1.0/YOUR-START-DATE/ <- <i>This route gets you to the minimum, average, and maximum temperature of your start date and all the dates greater than or equal to your start date.</i><br/>"
        f"/api/v1.0/YOUR-START-DATE/YOUR-END-DATE <- <i>This route leads to the minimum, average, and maximum temperature of the period between your start date and end date.</i><br/>"
        f"</br>"
        f"For example, if you would like to see those measures from 1st September 2016 to 30th September 2016, please use the following URL: /api/v1.0/2016-09-01/2016-09-30"
    )

# Precipitation query route:
@app.route('/api/v1.0/precipitation')
def precipitation_query():
    last_year_precipitation_scores_l = session.query(measurement.date, measurement.prcp).filter(measurement.date > the_year_before()).all()
    session.close()
    last_year_precipitation_scores_d = dict(last_year_precipitation_scores_l)
    return jsonify(last_year_precipitation_scores_d)
    
# Stations query route:
@app.route('/api/v1.0/stations')
def stations_query():
    station = Base.classes.station
    stations_l = session.query(station.id, station.station, station.name, station.latitude, station.longitude, station.elevation).all()
    stations_d = []
    for id, station, name, latitude, longitude, elevation in stations_l:
        stations_temp_d = {}
        stations_temp_d['id'] = id
        stations_temp_d['station'] = station
        stations_temp_d['name'] = name
        stations_temp_d['latitude'] = latitude
        stations_temp_d['longitude'] = longitude
        stations_temp_d['elevation'] = elevation
        stations_d.append(stations_temp_d)
    session.close()
    return jsonify(stations_d)

# Temperatures query route:
@app.route('/api/v1.0/tobs')
def temperatures_query():
    most_active_stations_a = session.query(measurement.station, func.count(measurement.date)).group_by(measurement.station).order_by(func.sum(measurement.station).desc()).all()
    sorted_most_active_stations_a = sorted(most_active_stations_a, key=lambda x: -x[1])
    most_active_station = sorted_most_active_stations_a[0][0]
    last_year_temperature_data_most_active_station_l = session.query(measurement.date, measurement.tobs).filter(measurement.date > the_year_before()).filter(measurement.station == most_active_station).all()
    session.close()
    last_year_temperature_data_most_active_station_d = dict(last_year_temperature_data_most_active_station_l)
    final_d = [{'most_active_station': most_active_station}, {'dates_and_temperatures': last_year_temperature_data_most_active_station_d}]
    return jsonify(final_d)

# Dynamic routes:
@app.route("/api/v1.0/<start>", defaults={"end": None})
@app.route("/api/v1.0/<start>/<end>")
def selected_dates(start, end):
    
    # Defined those 2 variables to make it easier to distinguish what column is being called:
    temperature_db = measurement.tobs
    date_db = measurement.date

    #Define selector for query
    sel=[func.min(temperature_db),
         func.avg(temperature_db),
         func.max(temperature_db),
         func.min(date_db),
         func.max(date_db)]
   
    # Query without "end" parameter
    if end == None:
        (TMIN, TAVG, TMAX, DMIN, DMAX) = session.query(*sel).filter(date_db>=start).one()
    # Query with "end" parameter
    else:
        (TMIN, TAVG, TMAX, DMIN, DMAX) = session.query(*sel).filter(date_db>=start).filter(date_db<=end).one()
    
    session.close()
    
    #Create dictionary to save results
    temp_dict={"1_start_date": DMIN,
               "2_end_date": DMAX,
               "3_MIN_Temp": TMIN,
               "4_AVG_Temp": TAVG,
               "5_MAX_Temp": TMAX}
    
    #Return jsonified dictionary
    return jsonify(temp_dict)

# To run the app:
if __name__ == "__main__":
    app.run(debug=True)
    