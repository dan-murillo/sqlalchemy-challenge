# Imported all the dependencies:
import sqlalchemy
from sqlalchemy.ext.automap import automap_base
from sqlalchemy.orm import Session
from sqlalchemy import create_engine, func
from flask import Flask, jsonify
import datetime as dt


#################################################
# Database Setup
#################################################
# Created an engine to my 'hawaii.sqlite' database:
engine = create_engine('sqlite:///Resources/hawaii.sqlite')

# Reflected the existing database into a new model:
Base = automap_base()

# Also reflected the tables:
Base.prepare(autoload_with=engine)

# Saved a reference to each table in the database:
station = Base.classes.station
measurement = Base.classes.measurement

# Created my session (link) from Python to the database:
session = Session(engine)


#################################################
# Flask Setup
#################################################
# Created an app to pass __name__:
app = Flask(__name__)


#################################################
# Flask Routes
#################################################
# Defined a function to find the date one year from the last date in the dataset; this function is used twice (in the precipitation and temperature routes):
def the_year_before():
    most_recent_datapoint = session.query(func.max(measurement.date)).scalar()
    reformatted_most_recent_datapoint = dt.datetime.strptime(most_recent_datapoint, '%Y-%m-%d').date()
    one_year_before = reformatted_most_recent_datapoint - dt.timedelta(days=365)
    return (one_year_before)

# Created the 'homepage' (landing page) route:
@app.route('/')
def homepage():
    # Listed all the available routes, described where the route takes the user, and gave helpful tips where appropriate:
    print("The server received a request for the homepage...")
    return (
        f"<h1>Welcome to the API for <i>my Hawaiian Holiday</i>!</h1><br/>"
        f"This API will help you find all the weather info of the islands that I found while planning my Hawaiian holiday."
        f"<h2>Fascinating weather info:</h2>"
        f"/api/v1.0/precipitation <-- <i>This route leads to the data generated by the precipitation analysis I did of the last 12 months of data.</i><br/>"
        f"/api/v1.0/stations <-- <i>This route has data about the stations in Hawaii.</i><br/>"
        f"/api/v1.0/tobs <-- <i>This route takes you to the dates and temperature observations of the most active station for the last year of data.</i><br/>"
        f"<h2>Find the stats of a specific period!</h2>"
        f"If you would like to know the minimum, average, and maximum temperature of specific dates in Hawaii, you can specify the start and end dates that you would like to query in the URL. Please use the YYYY-MM-DD format.</br>"
        f"</br>"
        f"/api/v1.0/YOUR-START-DATE/ <-- <i>This route gets you to the minimum, average, and maximum temperature of your start date and all the dates greater than or equal to your start date.</i><br/>"
        f"/api/v1.0/YOUR-START-DATE/YOUR-END-DATE <-- <i>This route leads to the minimum, average, and maximum temperature of the period between your start date and end date.</i><br/>"
        f"</br>"
        f"For example, if you would like to see those measures from 1st September 2016 to 30th September 2016, please use the following URL: /api/v1.0/2016-09-01/2016-09-30"
    )


# Created the 'precipitation' query route:
@app.route('/api/v1.0/precipitation')
def precipitation_query():
    # Queried the precipitation columns for the last 12 months of data by using the 'the_year_before' function I created:
    last_year_precipitation_scores_l = session.query(measurement.date, measurement.prcp).filter(measurement.date > the_year_before()).all()
    
    # Closed the session:
    session.close()
    
    # Converted the queried data to a dictionary:
    last_year_precipitation_scores_d = dict(last_year_precipitation_scores_l)

    # Returned a JSON with the date as the key and the precipitation as the value:
    return jsonify(last_year_precipitation_scores_d)


# Created the 'stations' query route:
@app.route('/api/v1.0/stations')
def stations_query():
    # Defined 'station' as a local variable:
    station = Base.classes.station

    # Queried the data of all the stations in the database:
    stations_l = session.query(station.id, station.station, station.name, station.latitude, station.longitude, station.elevation).all()
    
    # Created an empty list to store the data:
    stations_d = []

    # Looped to append the stations' data to the 'stations_d' list of dictionaries:
    for id, station, name, latitude, longitude, elevation in stations_l:
        stations_temp_d = {}
        stations_temp_d['id'] = id
        stations_temp_d['station'] = station
        stations_temp_d['name'] = name
        stations_temp_d['latitude'] = latitude
        stations_temp_d['longitude'] = longitude
        stations_temp_d['elevation'] = elevation
        stations_d.append(stations_temp_d)
    
    # Closed the session:
    session.close()
    
    # Returned a JSON with the data of all the stations in the database:
    return jsonify(stations_d)


# Created the 'temperatures' query route:
@app.route('/api/v1.0/tobs')
def temperatures_query():
    # Designed a query to find the most active stations:
    most_active_stations_a = session.query(measurement.station, func.count(measurement.date)).group_by(measurement.station).order_by(func.sum(measurement.station).desc()).all()
    
    # Sorted the stations in descending order:
    sorted_most_active_stations_a = sorted(most_active_stations_a, key=lambda x: -x[1])

    # Stored the most active station in a variable:
    most_active_station = sorted_most_active_stations_a[0][0]

    # Queried the last 12 months of temperature observation data of the most active station by using the 'the_year_before' function I created and saved the list of data:
    last_year_temperature_data_most_active_station_l = session.query(measurement.date, measurement.tobs).filter(measurement.date > the_year_before()).filter(measurement.station == most_active_station).all()
    
    # Closed the session:
    session.close()

    # Converted the queried data to a dictionary:
    last_year_temperature_data_most_active_station_d = dict(last_year_temperature_data_most_active_station_l)
    
    # Created a final dictionary that not only included the queried data, but also the name of the station where the data comes from as a reminder for the user:
    final_d = [{'most_active_station': most_active_station}, {'dates_and_temperatures': last_year_temperature_data_most_active_station_d}]
    
    # Returned a JSON with the data of the final dictionary:
    return jsonify(final_d)


# Created the 'start' dynamic route, which defaults to 'end' as 'none':
@app.route("/api/v1.0/<start>", defaults={"end": None})
# Created the 'start/end' dynamic route:
@app.route("/api/v1.0/<start>/<end>")
def selected_dates(start, end):
    
    # Defined the following 2 variables to make it easier to distinguish what column is being called:
    temperature_db = measurement.tobs
    date_db = measurement.date

    # Defined the selector for the query:
    sel=[func.min(temperature_db),
         func.avg(temperature_db),
         func.max(temperature_db),
         func.min(date_db),
         func.max(date_db)]
   
    # Created a conditional to work with queries without 'end' parameters; it will return the min, max, and average temperatures calculated from the given start date to the end of the dataset:
    if end == None:
        (TMIN, TAVG, TMAX, DMIN, DMAX) = session.query(*sel).filter(date_db>=start).one()
    # Defined what happens when there is an end date; it will return the min, max, and average temperatures calculated from the given start date to the given end date:
    else:
        (TMIN, TAVG, TMAX, DMIN, DMAX) = session.query(*sel).filter(date_db>=start).filter(date_db<=end).one()
    
    # Closed the session:
    session.close()
    
    # Created a dictionary to save the results:
    temp_dict={"1_start_date": DMIN,
               "2_end_date": DMAX,
               "3_MIN_Temp": TMIN,
               "4_AVG_Temp": TAVG,
               "5_MAX_Temp": TMAX}
    
    # Returned a JSON with the data of the dictionary:
    return jsonify(temp_dict)

# Created this conditional to run the app:
if __name__ == "__main__":
    app.run(debug=True)